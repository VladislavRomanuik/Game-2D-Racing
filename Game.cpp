// ---------------------------------------------------------------------------

#pragma hdrstop
// подключаем заглавный файл модуля Game (для определения методов классов)
#include "Game.h"
#include "Main.h"
// ---------------------------------------------------------------------------
#pragma package(smart_init)
// ЗДЕСЬ БУДЕТ ПРОХОДИТЬ САМО ОПИСАНИЕ ФУНКЦИЙ, КОТОРЫЕ МЫ ОПИСАЛИ В ПРОТОТИПАХ В .h

// extern - использование переменной score, что обьявлена в файле Game.h
extern int score;
extern bool lookBonus;

// функция возвращает правый X
int GameObject::GetRightX() {
	// return - возвращает что-то (в нашем случае координату)
	return xRight;
}

// функция возвращает левый X
int GameObject::GetLeftX() {
	// return - возвращает что-то (в нашем случае координату)
	return xLeft;
}

// функция возвращает верхний Y
int GameObject::GetTopY() {
	// return - возвращает что-то (в нашем случае координату)
	return yTop;
}

// функция возвращает нижний Y
int GameObject::GetBottomY() {
	// return - возвращает что-то (в нашем случае координату)
	return yBottom;
}

// устанавливаем левый X, функция с параметром, параметр в скобочках
void GameObject::SetLeftX(int xLeft) {
	// this -> УКАЗАТЕЛЬ НА ПЕРЕМЕННУЮ КЛАССА, ОДИНАКОВЫ НАЗВАНИЯ, НО С ПОМОЩЬЮ THIS РАЗНЫЕ ЗНАЧЕНИЕ
	// приравниваем переменной класса значение с параметра
	this->xLeft = xLeft;
}

// устанавливаем правый X, функция с параметром, параметр в скобочках
void GameObject::SetRightX(int xRight) {
	// this -> УКАЗАТЕЛЬ НА ПЕРЕМЕННУЮ КЛАССА, ОДИНАКОВЫ НАЗВАНИЯ, НО С ПОМОЩЬЮ THIS РАЗНЫЕ ЗНАЧЕНИЕ
	// приравниваем переменной класса значение с параметра
	this->xLeft = xLeft;
	this->xRight = xRight;
}

// устанавливаем верхний У, функция с параметром, параметр в скобочках
void GameObject::SetTopY(int yTop) {
	// this -> УКАЗАТЕЛЬ НА ПЕРЕМЕННУЮ КЛАССА, ОДИНАКОВЫ НАЗВАНИЯ, НО С ПОМОЩЬЮ THIS РАЗНЫЕ ЗНАЧЕНИЕ
	// приравниваем переменной класса значение с параметра
	this->yTop = yTop;
}

// устанавливаем нижний У, функция с параметром, параметр в скобочках
void GameObject::SetBottomY(int yBottom) {
	// this -> УКАЗАТЕЛЬ НА ПЕРЕМЕННУЮ КЛАССА, ОДИНАКОВЫ НАЗВАНИЯ, НО С ПОМОЩЬЮ THIS РАЗНЫЕ ЗНАЧЕНИЕ
	// приравниваем переменной класса значение с параметра
	this->yBottom = yBottom;
}

// переопределение метода рисовать Машинку игрока, функция с параметром, параметр в скобочках
void PlayerCar::DrawObj(int newLeftX) {
	// устанавливаем левую координату, это текущая координата + координата смещения
	SetLeftX(GetLeftX() + newLeftX);
	// устанавливаем левую координату картинки
	im->Left = GetLeftX();
	// устанавливаем Правую координату по X, Координата левая + ширина картинки
	SetRightX(GetLeftX() + im->Width);
}

// переопределение метода рисовать Дорогу, функция с параметром, параметр в скобочках
void Road::DrawObj(int newTopY) {
	// устанавливаем верхнюю координату, это текущая координата + координата смещения
	SetTopY(GetTopY() + newTopY);
	// устанавливаем верхнюю координату картинки
	im->Top = GetTopY();
}

// переопределение метода рисовать Машинку ОПОНЕНТА, функция с параметром, параметр в скобочках
void OpponentCar::DrawObj(int newTopY) {
	// устанавливаем верхнюю координату, это текущая координата + координата смещения
	SetTopY(GetTopY() + newTopY);
	// устанавливаем верхнюю координату картинки
	im->Top = GetTopY();
	// устанавливаем правую координату, Текузая координата левая + ширина картинки
	SetRightX(GetLeftX() + im->Width);
	// устанавливаем нижнюю коодринату по Y, Текущая координата + высота картинки
	SetBottomY(GetTopY() + im->Height);
}

// переопределение метода рисовать БОНУС, функция с параметром, параметр в скобочках
void Bonus::DrawObj(int newTopY) {
	// устанавливаем верхнюю координату, это текущая координата + координата смещения
	SetTopY(GetTopY() + newTopY);
	// устанавливаем верхнюю координату картинки
	im->Top = GetTopY();
	// устанавливаем правую координату, Текузая координата левая + ширина картинки
	SetRightX(GetLeftX() + im->Width);
	// устанавливаем нижнюю коодринату по Y, Текущая координата + высота картинки
	SetBottomY(GetTopY() + im->Height);
}

// функция включения бонуса
void Game::BonusActive() {
	// Проверка на тип бонуса
	// если это бонус типа 1 (добавления очков), то
	if (gameObject[8]->typeBonus == 1) {
		// добавляем 10 очков
		score += 10;
	}
	// если это бонус типа 2 (бессмертие), то
	if (gameObject[8]->typeBonus == 2) {
		// ВКЛЮЧАЕМ БЕССМЕРТИЕ
		immortality = true;
	}
}

// описание ГЛАВНОЙ ФУНКЦИИ ИГРЫ!!!!!!!!! КОЛИЗИЯ + ОТРИСОВКА + СМЕЩЕНИЕ ДОРОГИ  !!!!!!!!!!!!!!!!
void Game::GamePlay(int speedCar) {
	// проверка на пустоту бонуса
	if (gameObject[8] != NULL) {
		// смеена координаты смещения вниз для бонуса
		gameObject[8]->newCoord = speedCar;
	}
	// цыкл, прохождение по всем игровым элементам
	for (int i(0); i < 9; i++) {
		// проверка на конец дороги, если координата верха дороги больше 1000 и этот объект ДОРОГА (i = 1,2,3,4)
		if (gameObject[i]->GetTopY() > 904 && i > 0 && i < 5) {
			// то устанавливаем координату по У дороги выше видимости карты (-195)
			gameObject[i]->SetTopY(-395);
			// и координату смещения в 0 NEWCOORD - КООРДИНАТА СМЕЩЕНИЯ
			gameObject[i]->newCoord = 0;
		}
		// ПРОВЕРКА, ЕСЛИ ЭТО ОБЪЕКТЫ ДОРОГИ ИЛИ МАШИНОК ОПОНЕНТОВ СМЕЩЕНИЕ ПО ИГРИКУ = 5
		if (i > 0 && i < 5) {
			gameObject[i]->newCoord = 5;
		}
		// ПРОВЕРКА НА СТОЛКНОВЕНИЕ ГЛАВНОЙ МАШИНКИ С МАШИНКАМИ ОПОНЕНТА
		if (i > 4 && i < 8) {
			// ПРОВЕРКА СТОЛКНОВЕНИЯ ИГРОКа ОБ ЛЕВУЮ МАШИНКУ
			// ТУТ ПРОИСХОДИТ ПРОВЕРКА СТОЛКНОВЕНИЯ ПО КООРДИНАТЕ
			// В ЛС ЕСТЬ КАРТИНКА С ЭТИМ ОБЪЯСНЕНИЕМ

			if (gameObject[i]->GetBottomY() >= gameObject[0]->GetTopY() -
				5 && gameObject[i]->GetBottomY() <= gameObject[0]->GetTopY() +
				5 && gameObject[i]->GetLeftX() >= gameObject[0]->GetLeftX() -
				55 && gameObject[i]->GetRightX() <= gameObject[0]->GetRightX()
				+ 55) {
				// Проверка на бессмертие
				if (immortality) {
					// если ударился и ты ессмертный, удаляется машинка опонента
					delete gameObject[i];
					// создается машинка опонента в памяти, ЧТОБЫ НЕ БЫЛО ОШИБКИ С ПАМЯТЬЮ
					gameObject[i] = new OpponentCar(300, -10000, 1);
					// выключаем бессмертие
					immortality = false;
					// так как при столкновении использовали возможность бессмертия, вырубаем картинку
					lookBonus = false;
				}
				// Иначе, если не бессмертный
				else {
					// убираем бессмертность
					immortality = false;
					// конец игры
					game_ = false;
					// так как при столкновении использовали возможность бессмертия, вырубаем картинку
					lookBonus = false;
				}
			}
			// ПРОВЕРКА НА СТОЛКНОВЕИЕ ИГРОКА С БОКАМИ ДРУГИГ МАШИН
			// ПРОВЕРКА ПОКООРДИНАТНО, СМОТРИ КАРТИНКУ
			if (gameObject[0]->GetBottomY() >= gameObject[i]->GetBottomY() -
				70 && gameObject[0]->GetTopY() <= gameObject[i]->GetTopY() +
				70 && (gameObject[0]->GetLeftX() - 3) <=
				gameObject[i]->GetRightX() && (gameObject[0]->GetLeftX() + 3) >=
				gameObject[i]->GetRightX()) {
				// ПОСЛЕ СТОЛКНОВЕНИЯ ИГРОКА СМЕЩЕНИЕ ВПРАВО на 1 ИГРОКА
				gameObject[0]->newCoord = 1;
			}
			// ПРОВЕРКА СТОЛКНОВЕНИЯ ИГРОКа ОБ ЛЕВУЮ МАШИНКУ
			// ТУТ ПРОИСХОДИТ ПРОВЕРКА СТОЛКНОВЕНИЯ ПО КООРДИНАТЕ
			// В ЛС ЕСТЬ КАРТИНКА С ЭТИМ ОБЪЯСНЕНИЕМ
			else if (gameObject[0]->GetBottomY() >= gameObject[i]->GetBottomY()
				- 70 && gameObject[0]->GetTopY() <= gameObject[i]->GetTopY() +
				70 && (gameObject[0]->GetRightX() + 3) >=
				gameObject[i]->GetLeftX() && (gameObject[0]->GetRightX() - 3) <=
				gameObject[i]->GetLeftX()) {
				// ПОСЛЕ СТОЛКНОВЕНИЯ ИГРОКА СМЕЩЕНИЕ ВЛЕВО на 1 ИГРОКА
				gameObject[0]->newCoord = -1;
			}

			else {
				// ИНАЧЕ СМЕЩЕНИЕ НА SPEEDCAR вниз МАШИН ОПОНЕНТОА
				gameObject[i]->newCoord = speedCar;
			}
		}
	}
	// ПРОВЕРКА СТОЛКНОВЕНИЯ БОНУСА С ИГРОКОМ
	// СТОЛКНОВЕНИЕ ПОКООРДИНАТНО, СМОТРИ КАРТИНКУ
	if (gameObject[8]->GetBottomY() >= gameObject[0]->GetTopY() -
		5 && gameObject[8]->GetBottomY() <= gameObject[0]->GetTopY() +
		5 && gameObject[8]->GetLeftX() >= gameObject[0]->GetLeftX() -
		55 && gameObject[8]->GetRightX() <= gameObject[0]->GetRightX() + 55) {
		// Срабатывает метод БОНУС АКТИВ, СМОТРИ СТРОЧКУ 109
		BonusActive();
		// если бонус БЕССМЕРТИЕ
		if (gameObject[8]->typeBonus == 2)
		{
			// ВЫВОДИМ НА ЭКРАН КАРТИНКУ БОНУСА
			lookBonus = true;
		}
		// УДАЛЯЕМ БОНУС, ПОСЛЕ СТОЛКНОВЕНИЯ
		delete gameObject[8];
		// СОЗДАЕМ НОВЫЙ БОНУС, ЧТОБЫ УБРАТЬ ПРОБЛЕМ С ПАМЯТЬЮ
		gameObject[8] = new Bonus(300, -10000, 1);
	}
	// ОТРИСОВУЕМ ВСЕ ИГРОВЫЕ ОБЬЕКТЫ
	// проходим цыклом 9 объектов
	for (int i = 0; i < 9; i++) {
		// проверка на пустоту объекта
		if (gameObject[i] != NULL) {
			// отрисовуем объекты, параметр смещение
			gameObject[i]->DrawObj(gameObject[i]->newCoord);
		}
	}
}
